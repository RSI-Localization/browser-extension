import { CONFIG } from './config';
import { StorageManager } from './utils/storage';
import { LocaleButton } from './components/locale-button';
import './styles.css';

class Main {
    constructor() {
        this.locales = {};
        this.versions = {};
        this.initialized = false;
        this.currentLanguage = 'en';
        this.supportedLanguages = CONFIG.SUPPORTED_LANGUAGES;
        this.mutationObserver = null;
        this.popoverObserver = null;

        // 성능 최적화를 위한 설정
        this.BATCH_SIZE = 100; // 한 번에 처리할 노드 수
        this.PROCESS_INTERVAL = 16; // 처리 간격 (ms)
        this.textCache = new Map(); // 번역 캐시
        this.processingQueue = []; // 처리 대기 큐
        this.isProcessing = false;

        this.numberRegex = /(?<!\w)\d+(\.\d+)?(?!\w)/g;
        this.placeholderRegex = /\{(\d+)}/g;
        this.mixedPattern = /\w*\d+\w*/g;
    }

    async initialize() {
        try {
            await this.loadUserSettings();
            await this.loadLocaleData();
            this.initialized = true;
            this.setupEventListeners();
            this.observePopover();

            if (this.currentLanguage !== 'en') {
                await this.localizePage();
            }

            console.log('WebsiteLocalizer initialized successfully');
        } catch (error) {
            console.error('Failed to initialize WebsiteLocalizer:', error);
        }
    }

    async loadUserSettings() {
        try {
            const settings = await StorageManager.get({
                language: 'en',
                hostname: window.location.hostname
            });

            // 현재 호스트네임에 대한 설정만 로드
            if (settings.hostname === window.location.hostname) {
                this.currentLanguage = settings.language;
            }
        } catch (error) {
            console.error('Failed to load user settings:', error);
        }
    }

    async saveUserSettings() {
        try {
            await StorageManager.set({
                language: this.currentLanguage,
                hostname: window.location.hostname
            });
        } catch (error) {
            console.error('Failed to save user settings:', error);
        }
    }

    async loadLocaleData(specificLocale = null) {
        try {
            const localesToLoad = specificLocale
                ? [specificLocale]
                : Object.keys(this.supportedLanguages);

            for (const locale of localesToLoad) {
                if (locale === 'en') continue;

                const response = await new Promise((resolve) => {
                    chrome.runtime.sendMessage({
                        action: 'getLocaleData',
                        locale: locale
                    }, resolve);
                });

                if (response && response[`locale_${locale}`]) {
                    this.locales[locale] = response[`locale_${locale}`];
                    this.versions[locale] = response[`version_${locale}`];
                    console.log(`Loaded ${locale} locale version ${this.versions[locale]}`);
                }
            }
        } catch (error) {
            console.error('Failed to load locale data:', error);
        }
    }

    setupEventListeners() {
        // 로케일 업데이트 수신 리스너
        chrome.runtime.onMessage.addListener((message) => {
            if (message.action === 'localeUpdated') {
                this.handleLocaleUpdate(message.locale);
            }
        });
    }

    async handleLocaleUpdate(locale) {
        try {
            await this.loadLocaleData(locale);
            if (this.currentLanguage === locale) {
                await this.localizePage();
            }
        } catch (error) {
            console.error('Failed to handle locale update:', error);
        }
    }

    observePopover() {
        // 팝오버 요소 감시
        this.popoverObserver = new MutationObserver((mutations) => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === Node.ELEMENT_NODE &&
                        node.classList.contains('o-localizationPopover')) {
                        this.addLanguageOptions();
                    }
                });
            });
        });

        this.popoverObserver.observe(document.body, {
            childList: true,
            subtree: true
        });
    }

    addLanguageOptions() {
        const popover = document.querySelector('.m-popover.o-localizationPopover');
        if (!popover) return;

        const languageBlock = popover.querySelector('.c-localizationBlock__content');
        if (!languageBlock) return;

        if (languageBlock.dataset.localizerProcessed === 'true') return;
        languageBlock.dataset.localizerProcessed = 'true';

        const createLanguageButtons = (templateButton = null) => {
            Object.entries(this.supportedLanguages).forEach(([langCode, langName]) => {
                if (langCode === 'en') return;

                // 기존 버튼 확인 로직 수정
                const existingButton = Array.from(languageBlock.querySelectorAll('.m-localizationItem__label'))
                    .find(label => label.textContent.trim() === langName);

                if (existingButton) return;

                const button = new LocaleButton(
                    langName,
                    langCode === this.currentLanguage,
                    () => this.handleLanguageSelect(langCode)
                ).create(templateButton);

                if (button) {
                    button.setAttribute('data-lang', langCode);
                    languageBlock.appendChild(button);
                }
            });

            // 확인 버튼 설정 추가
            this.setupConfirmButton(popover);
        };

        const templateButton = languageBlock.querySelector('.m-localizationItem');
        if (templateButton) {
            createLanguageButtons(templateButton);
        } else {
            const observer = new MutationObserver((mutations, obs) => {
                const template = languageBlock.querySelector('.m-localizationItem');
                if (template) {
                    createLanguageButtons(template);
                    obs.disconnect();
                }
            });

            observer.observe(languageBlock, {
                childList: true,
                subtree: true,
                attributes: false,
                characterData: false
            });

            setTimeout(() => {
                observer.disconnect();
                if (!languageBlock.querySelector('.m-localizationItem[data-lang]')) {
                    createLanguageButtons();
                }
            }, 5000);
        }
    }

    setupConfirmButton(popover) {
        const confirmButton = popover.querySelector('.a-button.-filled');
        if (!confirmButton) return;

        const originalClickHandler = confirmButton.onclick;
        confirmButton.onclick = async (e) => {
            const languageBlock = popover.querySelector('.c-localizationBlock__content');
            const activeButton = languageBlock.querySelector('.m-localizationItem.-active');

            if (activeButton) {
                // data-lang 속성을 사용하여 언어 코드 직접 가져오기
                const activeLangCode = activeButton.getAttribute('data-lang') || 'en';
                await this.changeLanguage(activeLangCode);
            }

            if (originalClickHandler) {
                originalClickHandler.call(confirmButton, e);
            }
        };
    }

    async changeLanguage(langCode) {
        try {
            this.currentLanguage = langCode;
            await this.saveUserSettings();

            if (langCode === 'en') {
                this.restoreOriginal();
            } else {
                await this.localizePage();
            }
        } catch (error) {
            console.error('Failed to change language:', error);
        }
    }

    handleLanguageSelect(langCode) {
        const languageBlock = document.querySelector('.c-localizationBlock__content');
        if (!languageBlock) return;

        const buttons = languageBlock.querySelectorAll('.m-localizationItem');
        buttons.forEach(button => {
            const label = button.querySelector('.m-localizationItem__label');
            if (label) {
                // data-lang 속성을 사용하여 비교
                const isActive = button.getAttribute('data-lang') === langCode ||
                    (!button.hasAttribute('data-lang') && langCode === 'en');
                button.classList.toggle('-active', isActive);
            }
        });
    }

    sanitizeText(text) {
        const sanitized = text.trim().replace(/\s+/g, ' ');
        // 최소 길이 필터링 (공백이나 특수문자만 있는 경우 제외)
        return sanitized.length > 1 && /\w+/.test(sanitized) ? sanitized : '';
    }

    async processNodeBatch(nodes) {
        const replacements = [];

        for (const node of nodes) {
            const localizedNode = await this.processTextNode(node);
            if (localizedNode) {
                replacements.push({ original: node, localized: localizedNode });
            }
        }

        // DOM 업데이트는 한 번에 수행
        replacements.forEach(({ original, localized }) => {
            if (original.parentNode) {
                original.parentNode.replaceChild(localized, original);
            }
        });
    }

    async processQueue() {
        if (!this.processingQueue.length || this.isProcessing) return;

        this.isProcessing = true;
        const batch = this.processingQueue.splice(0, this.BATCH_SIZE);

        try {
            await this.processNodeBatch(batch);

            // 다음 배치 처리를 위한 스케줄링
            if (this.processingQueue.length) {
                setTimeout(() => {
                    this.isProcessing = false;
                    this.processQueue();
                }, this.PROCESS_INTERVAL);
            } else {
                this.isProcessing = false;
            }
        } catch (error) {
            console.error('Error processing text nodes:', error);
            this.isProcessing = false;
        }
    }

    async localizeElement(element) {
        const excludeTags = ['SCRIPT', 'STYLE', 'CODE', 'PRE', 'IFRAME'];

        if (excludeTags.includes(element.tagName)) {
            return;
        }

        // 텍스트 노드 수집
        const walker = document.createTreeWalker(
            element,
            NodeFilter.SHOW_TEXT,
            {
                acceptNode: (node) => {
                    const text = this.sanitizeText(node.textContent);
                    return text ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
                }
            },
            false
        );

        const textNodes = [];
        let node;
        while (node = walker.nextNode()) {
            textNodes.push(node);
        }

        // 수집된 노드들을 처리 큐에 추가
        this.processingQueue.push(...textNodes);
        await this.processQueue();

        // 속성 현지화 (비동기로 처리)
        await this.localizeAttributes(element);
    }

    async localizeAttributes(element) {
        const localizableAttributes = ['placeholder', 'title', 'alt', 'aria-label'];
        const promises = [];

        const processAttribute = async (el, attr) => {
            if (el.hasAttribute(attr)) {
                const text = this.sanitizeText(el.getAttribute(attr));
                if (!text) return;

                let localizedText;
                if (this.textCache.has(text)) {
                    localizedText = this.textCache.get(text);
                } else {
                    localizedText = this.locales[this.currentLanguage]?.strings[text];
                    if (localizedText) {
                        this.textCache.set(text, localizedText);
                    }
                }

                if (localizedText) {
                    el.setAttribute(attr, localizedText);
                    el.setAttribute(`data-original-${attr}`, text);
                    el.setAttribute('data-lang', this.currentLanguage);
                }
            }
        };

        // 현재 요소의 속성 처리
        localizableAttributes.forEach(attr => {
            promises.push(processAttribute(element, attr));
        });

        // 하위 요소들의 속성도 처리
        const elements = element.getElementsByTagName('*');
        for (const el of elements) {
            localizableAttributes.forEach(attr => {
                promises.push(processAttribute(el, attr));
            });
        }

        await Promise.all(promises);
    }

    extractNumbersFromText(text) {
        // 알파벳과 숫자가 혼합된 패턴은 제외하고 순수 숫자만 추출
        const mixedPatterns = text.match(this.mixedPattern) || [];
        let processedText = text;

        // 혼합 패턴을 임시로 제거
        mixedPatterns.forEach(pattern => {
            processedText = processedText.replace(pattern, '');
        });

        // 남은 순수 숫자만 추출
        const numbers = processedText.match(this.numberRegex);
        return numbers ? numbers.map(n => parseInt(n, 10)) : [];
    }

    convertToPattern(text) {
        // 혼합 패턴을 보존하면서 순수 숫자만 플레이스홀더로 변환
        const mixedPatterns = text.match(this.mixedPattern) || [];
        let processedText = text;
        const preservedPatterns = new Map();

        // 혼합 패턴을 임시 토큰으로 치환
        mixedPatterns.forEach((pattern, index) => {
            const token = `__MIXED_${index}__`;
            preservedPatterns.set(token, pattern);
            processedText = processedText.replace(pattern, token);
        });

        // 순수 숫자를 플레이스홀더로 변환
        let counter = 0;
        processedText = processedText.replace(this.numberRegex, () => `{${counter++}}`);

        // 임시 토큰을 원래 패턴으로 복원
        preservedPatterns.forEach((pattern, token) => {
            processedText = processedText.replace(token, pattern);
        });

        return processedText;
    }

    // 패턴에 숫자를 다시 삽입
    insertNumbersIntoPattern(pattern, numbers) {
        return pattern.replace(this.placeholderRegex, (match, index) => {
            const numberIndex = parseInt(index, 10);
            return numberIndex < numbers.length ? numbers[numberIndex].toString() : match;
        });
    }

    async processTextNode(node) {
        const text = this.sanitizeText(node.textContent);
        if (!text) return null;

        // 캐시된 정적 텍스트 확인
        if (this.textCache.has(text)) {
            const localizedText = this.textCache.get(text);
            return localizedText ? this.createLocalizedTextNode(node, localizedText, false) : null;
        }

        const numbers = this.extractNumbersFromText(text);
        const hasNumbers = numbers.length > 0;

        if (hasNumbers) {
            // 숫자를 플레이스홀더로 변환하여 패턴 매칭
            const pattern = this.convertToPattern(text);
            const localizedPattern = this.locales[this.currentLanguage]?.strings[pattern];

            if (localizedPattern) {
                // 번역된 패턴에 원래 숫자들을 삽입
                const localizedText = this.insertNumbersIntoPattern(localizedPattern, numbers);
                return this.createLocalizedTextNode(node, localizedText, true, pattern);
            }
        } else {
            // 일반 텍스트 처리
            const localizedText = this.locales[this.currentLanguage]?.strings[text];
            if (localizedText) {
                this.textCache.set(text, localizedText);
                return this.createLocalizedTextNode(node, localizedText, false);
            }
        }

        return null;
    }

    createLocalizedTextNode(originalNode, localizedText, isDynamic, pattern = null) {
        const span = document.createElement('span');
        span.textContent = localizedText;
        span.classList.add('localized-text');

        if (isDynamic) {
            span.classList.add('dynamic-text');
            span.dataset.pattern = pattern;
        } else {
            span.dataset.originalText = originalNode.textContent;
        }

        return span;
    }

    // 동적 텍스트 업데이트를 위한 MutationObserver
    setupDynamicTextObserver() {
        const observer = new MutationObserver((mutations) => {
            mutations.forEach(mutation => {
                if (mutation.type === 'characterData') {
                    const targetNode = mutation.target.parentNode;
                    if (targetNode?.classList.contains('dynamic-text')) {
                        this.updateDynamicText(targetNode);
                    }
                }
            });
        });

        observer.observe(document.body, {
            characterData: true,
            subtree: true
        });

        return observer;
    }

    updateDynamicText(element) {
        const pattern = element.dataset.pattern;
        if (!pattern) return;

        const currentText = element.textContent;
        const numbers = this.extractNumbersFromText(currentText);
        if (numbers.length === 0) return;

        const localizedPattern = this.locales[this.currentLanguage]?.strings[pattern];
        if (localizedPattern) {
            element.textContent = this.insertNumbersIntoPattern(localizedPattern, numbers);
        }
    }

    async localizePage() {
        if (!this.initialized || !this.locales[this.currentLanguage]) {
            console.warn('Localizer not initialized or language not supported');
            return;
        }

        this.textCache.clear();
        this.processingQueue = [];
        this.isProcessing = false;

        await this.localizeElement(document.body);

        // 기존 MutationObserver 설정
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }

        this.mutationObserver = new MutationObserver((mutations) => {
            mutations.forEach(mutation => {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        this.localizeElement(node);
                    }
                });
            });
        });

        this.mutationObserver.observe(document.body, {
            childList: true,
            subtree: true
        });

        // 동적 텍스트 옵저버 설정
        this.setupDynamicTextObserver();
    }

    restoreOriginal() {
        const localizedElements = document.querySelectorAll('.localized-text');
        localizedElements.forEach(element => {
            const originalText = element.dataset.originalText;
            if (originalText) {
                const textNode = document.createTextNode(originalText);
                element.parentNode.replaceChild(textNode, element);
            }
        });

        // 속성 복원
        const attributeSelector = Object.keys(this.supportedLanguages)
            .map(lang => `[data-original-placeholder][data-lang="${lang}"],` +
                `[data-original-title][data-lang="${lang}"],` +
                `[data-original-alt][data-lang="${lang}"],` +
                `[data-original-aria-label][data-lang="${lang}"]`)
            .join(',');

        const elementsWithAttributes = document.querySelectorAll(attributeSelector);
        elementsWithAttributes.forEach(element => {
            ['placeholder', 'title', 'alt', 'aria-label'].forEach(attr => {
                const originalValue = element.getAttribute(`data-original-${attr}`);
                if (originalValue) {
                    element.setAttribute(attr, originalValue);
                    element.removeAttribute(`data-original-${attr}`);
                }
            });
            element.removeAttribute('data-lang');
        });

        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }
    }

    cleanup() {
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
        }
        if (this.popoverObserver) {
            this.popoverObserver.disconnect();
        }
    }
}

// 초기화 및 실행
const main = new Main();
main.initialize().then();

// 페이지 언로드 시 정리
window.addEventListener('unload', () => {
    main.cleanup();
});